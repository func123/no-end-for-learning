# 字典

字典是一种保存键值对的抽象数据结构，而一个键可以和一个值进行关联（映射），具有这种关联关系的键和值就是键值对。

## Redis的字典实现

​	跟链表一样，C语言中没有内置字典这种数据结构，因此Redis构建了自己的字典实现。Redis的字典使用哈希表作为底层实现，一个哈希表中有多个哈希节点，而每个哈希表节点就保存一个字典中的键值对

### 哈希表实现

```go
typedef struct dictht {
      dictEntry ** table; 	// 哈希表数组，元素是指向dictEntry的指针
      unsigned long size;	  // 哈希表的大小
      unsigned long sizemask;	// 哈希表大小掩码，用于计算索引值。值为 size-1 
      unsigned long used;	// 哈希表中已有节点的数量
}
```

### 哈希表节点实现

```go
typedef struct dictEntry {
     void *key;	// 键
     union{	// 值
          void *val;	
          uint64_t u64;
          int64_t s64;
     } v;
     struct dictEntry *next;	// 指向下一个哈希节点，形成链表
} dictEntry;
```

​	哈希表节点的值可以是一个指针，也可以是一个`uint64_t`或者`int64_t`整数。另外通过`next`，可以将键相同的节点连成链表，解决键冲突的问题

### 字典实现

```go
typedef struct dict {
    dictType *type;	 // 类型特定函数
    void *privdata;	// 私有数据
    dictht ht[2];   // 哈希表数组
    long rehashidx; 	// rehash索引，标识rehash状态和进度
} dict;

typedef struct dictType {
    //	计算哈希值的函数 
    uint64_t (*hashFunction)(const void *key);
    //	复制key的函数 
    void *(*keyDup)(void *privdata, const void *key);
    //	复制value函数
    void *(*valDup)(void *privdata, const void *obj);
    //	对比key的函数
    int (*keyCompare)(void *privdata, const void *key1, const void *key2);
    //	销毁key的函数 
    void (*keyDestructor)(void *privdata, void *key);
     //	销毁value的函数 
    void (*valDestructor)(void *privdata, void *obj);
} dictType;
```

​	字典实现中的**类型特定函数**和**私有数据**是针对不同类型的键值对，为创建多态字典而设置的。**哈希表数组**是一个长度为2的数组，一般情况下字典只是用ht[0]哈希表，h[1]是为实现rehash使用的。**rehash索引**标识rehash的状态和进度，其值为-1时，表示目前没有在进行rehash。

![不处于rehash状态的字典实现](..\images\redis字典实现.jpg)

## 哈希算法

​	在将一个键值对放入字典中时，会通过字典设置的哈希函数计算出键对应的哈希值并与哈希表的索引值相与，决定该键值对在哈希表节点数组中的位置

### 解决键冲突

​	当两个或以上的键值对被分配到哈希数组的同一个索引位置上时，我们称这些键发生了冲突。

​	Redis的哈希表使用**链地址法**解决键冲突，通过`next`指针，多个哈希节点构成一个单向链表，从而将发生键冲突的多个节点连接起来。另外一方面，因为该单向链表没有指向链尾的指针，基于性能的考虑，程序总是将新节点添加到表头的位置：复杂度为O(1)，如果放在表尾需要遍历到表尾，复杂度为O(1)

## rehash

### 负载因子

​	负载因子指示哈希表保存数据的稀疏程度，其值等于哈希表中保存的键值对数量和哈希表大小的比值

```go
load_factor = ht[0].used / ht[0].size
```

### 执行rehash的具体实现

​	随着操作的不断进行，哈希表中保存的键值对数量会逐渐增多或者减少。为了保持负载因子在一个合理的范围，在键值对数量太多或太少时需要对哈希表的大小进行相应的扩展或收缩。而对哈希表大小进行扩展和收缩的操作是通过rehash（重新散列）来实现的。redis的哈希表rehash的步骤如下：

1. 为字典的`ht[1]`哈希表分配内存空间，空间大小取决于执行的操作以及当前`ht[0]`哈希表保存的键值对数量
   - 扩展：`ht[1]`的大小等于第一个大于等于二倍的`ht[0]`中的键值对数量的2^n
   - 收缩：`ht[1]`的大小等于等于`ht[0]`中的键值对数量的2^n
2. 将`ht[0]`上的键值对全部 **rehash** 到`ht[1]`上，rehash是指重新计算键的哈希值和哈希表的索引值，然后将键值对放置到`ht[1]`哈希节点数组的对应位置上
3. 当`ht[0]`上的键值对全部完成rehash后，此时`ht[0]`为空表，释放`ht[0]`的内存空间，将`ht[1]`设置为`ht[0]`并且为`ht[1]`新建一个空白的哈希表为下一次rehash做准备

### 执行rehash的触发时机

负载因子的动态变化会触发哈希表的扩展和收缩进而进行rehash：即哈希表的扩展和收缩的唯一影响因素是负载因子

- 扩展：根据情景的不同，触发哈希表扩展的负载因子阈值是不同的，可以分两种情况

  1. 当服务器目前没有执行`BGSAVE`或`BGREWRITEAOF`命令，负载因子大于等于1时，触发哈希表扩展
  2. 当服务器正在执行`BGSAVE`或`BGREWRITEAOF`命令，负载因子大于等于5时，才触发哈希表扩展

  根据服务器是否正在执行`BGSAVE`或`BGREWRITEAOF`命令，负载因子触发哈希表扩展的大小是不同的。这是因为在执行这两个命令时候，Redis需要创建当前服务器进程的子进程，而大多数服务器采用写时复制（copy-on-write）来优化子进程的使用效率，这要求尽量减少进程的写操作，因此通过提高执行扩展操作所需要的扩展因子来尽可能避免在子进程存在期间进行写操作，减少复制开销。

  > **写时复制**（英语：**Copy-on-write**，简称**COW**）是一种计算机[程序设计](https://zh.wikipedia.org/wiki/程式設計)领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。这过程对其他的调用者都是透明的（[transparently](https://zh.wikipedia.org/w/index.php?title=Transparency_(computing)&action=edit&redlink=1)）。此作法主要的优点是如果调用者没有修改该资源，就不会有副本（private copy）被创建，因此多个调用者只是读取操作时可以共享同一份资源。
  >
  > -- 维基百科
  >
  > 
  >
  > 写时复制技术的优点是什么？
  >
  > fork进程的时候，内存空间**是引用而不是复制的**。
  >
  > 意味着执行完fork后的两个进程的内存指向的是同一片区域。但是进程可能会执行不同的操作，产生不同的数据，这时候才在其他空闲内存区域写入一个新的对象并改写原指针。如果两个程序的大部分内存数据都是相同的，那么这个技术**能省下非常多的内存空间**。
  >
  > -- 知乎
  >
  > 
  >
  > 写时复制是有一块内存，由多个进程共享，属性是只读的，当有一个进程对这块内存进行写的时候，系统会先申请一块新的内存给他写。比如进程fork的时候，父子进程对应的物理地址都一样，这时候会在页表项中记录该物理地址是只读的，有一个进程写的时候，就会触发写保护异常。执行写时复制。
  >
  > -- 知乎
  >
  > 
  >
  > 写时复制：是指父子进程引用同一个内存空间，读取时能够共享资源，当发生写入操作时，才针对调用者单独进行复制。因此在父子进程存在期间，每次进行写入操作，都会引起资源复制。

  

- 收缩：当哈希表的负载因子小于0.1时，会自动对哈希表进行收缩操作

### 渐进式rehash

​	rehash时会将ht[0]的所有键值对迁移到ht[1]中，但是这个操作并不是一次性完成的，而是分多次，渐进式去完成的。这样做是为了避免在对大数量的键值对数量进行迁移时，庞大的计算量会让服务器在一段时间内无法提供服务的情况发生。

#### 渐进式rehash的具体实现

1. 为ht[1]分配内存空间，此时字典同时持有两个哈希表
2. 设置字典中`rehashidx`的值为0，表示开始进行rehash
3. 在rehash进行期间，对字典的增删改查操作都会额外将在`ht[0]`哈希表的`rehashidx`索引上的所有键值对 rehash 到`ht[1]`对应的索引位置上，并在完成后使`rehashidx`的值加一
4. 随着字典的增删改查的操作不断执行，终将在某个时间点上，完成`ht[0]`上所有键值对的搬迁工作，这时设置字典中`rehashidx`的值为-1，表示字典不处于rehash状态

#### 字典处于rehash状态时的API操作

​	字典在进行rehash时会同时持有新旧两个哈希表，在对字典进行删除、更新、查找操作时，需要处理新旧两个哈希表，而在字典进行新增操作时，只会将新的键值对保存在`ht[1]`哈希表上，这就保证了`ht[0]`哈希表的键值对数量是只减不增的。



