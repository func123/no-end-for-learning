# 简单动态字符串（SDS）	

​	Redis使用一种叫简单动态字符串（SDS）的抽象数据类型作为字符串的默认表示，而C字符串只会作为字符串字面量用在一些无须对字符串进行修改的地方。

​	SDS跟C字符串一样，用`'\0'`在内存中标识一个字符串的结束，但是在SDS中这个标识不会计算在`len`中。

```go
// sds 
struct sdshdr{
	int len 	// 字符串的长度，buf中已经使用的长度
	int free	// buf 中 未使用的长度
	char buf[]	// 字节数组，用来保存字符串
}
```

# SDS与C字符串的区别

## 常数复杂度获取字符串长度

- C字符串需要遍历字符串直到遇到`'\0'`为止，复杂度为O(N)
- SDS通过保存字符串的长度，可以在常数复杂度下获取到字符串的长度

## 杜绝缓冲区的溢出

- C字符串不保存字符串长度，因此在进行某些操作，例如拼接字符串时，容易造成缓冲区溢出
- SDS在进行拼接字符串时，先检查自身长度是否足够，决定是否先扩展空间，避免缓冲区的溢出

## 内存分配策略

​        C字符串的底层实现总是N+1个字符长的数组（额外的字符空间保存`'\0'`），因此C字符串的长度和底层数组的这种关系导致每次字符串发生修改，都需要重新分配内存空间：

- 字符串增长，例如拼接字符串，程序需要先通过内存分配扩展底层数组的大小，否则会造成缓冲区溢出
- 字符串缩短，例如截断操作，需要进行内存分配来释放底层数组不需要的那部分空间，否则会造成内存泄漏

​		因为内存分配涉及复杂的算法并且可能进行系统调用，因此通常是一个比较耗时的操作，而Redis作为数据库，经常被用于速度要求严苛和频繁修改的场合，因此如果每次修改字符串都需要执行一次内存分配，字符串的频繁修改会对性能造成很大影响

​		为了避免C字符串的这种缺陷，SDS通过未使用的空间来解除字符串长度与底层数组的关联：底层数组大小 = 字符串大小 + 未使用空间大小。通过未使用空间`free`，SDS实现了空间预分配和惰性释放两种优化策略

- **空间预分配**：SDS在修改并且需要扩展内存空间时会预分配空闲的空间：
  - 当修改后的字符串长度小于1Mb时会预分配等同于**字符串大小**的未使用空间
  - 当修改后的字符串长度大于1Mb时会**固定预分配1Mb**的未使用空间
- **惰性释放**：SDS的字符串缩小时，不会通过内存分配释放被删除的字符串，而是会把它记录到`free`中作为空闲空间为字符串将来可能的增长提供优化。与此同时，Redis也提供了相关的API接口在需要时真正释放SDS未使用的空间，避免内存浪费

## 二进制安全

> 二进制安全：数据在写入时是怎么样的，读取时就是怎么样，程序在读取时不会对其数据做任何限制、过滤，那么就是二进制安全的。例如一个C字符串A在写入时是：`redis cluster`,由于在C字符串中，空字符串是一个C字符串的结尾标记，因此在读取A时的结果是`redis`，跟原始数据不是相等的，因此就是二进制不安全的。

  	C字符串中的字符必须符合某种编码，并且由于是用空字符串`'\0'`作为字符串的结尾，因此字符串中不能包含空字符串，否则会被误认为是一个字符串结尾。这些原因使得C字符串只能保存字符而不能保存图片、音频等二进制数据。

​	Redis作为一个数据库，虽然一般是保存文本，但是用数据库来保存二进制数据的场景也不少见，为了确保Redis能适用于不同的场景，SDS的API都是二进制安全的，而SDS中的`buf`保存的不是字符而是一系列二进制数据。另一方面，由于SDS是用`len`来判断字符串长度，因此字符串中允许包含空字符串而不会被误认为是一个字符串结尾。

## 兼容C字符串的部分函数

​	跟C字符串一样，SDS的字符串结尾用空字符串`'\0'`标识，这是为了能够复用C字符串的部分函数。

# SDS的优点

总结来说，SDS具有以下优点：

1. SDS通过维护`len`字段，实现获取字符串长度的复杂度为常数
2. SDS的API在进行增长字符串长度的操作时，通过标识空余的内存空间的`free`字段，首先检查内存空间是否足够后，再进行内存分配，避免缓冲区的溢出
3. SDS预分配和惰性释放的内存分配策略，能够减少操作带来的内存分配的次数，保证连续N次的字符串增长操作的内存分配次数在至多N次而不是至少N次
4. 由于SDS被设计成保存二进制数据，所以SDS不仅能保存字符还能保存特殊的数据格式，而且SDS是二进制安全的，数据的读取不会被`'\0'`影响，写入的数据是和读取的数据是一致的。
5. 能够复用部分C字符串的函数，避免不必要的代码重复

​		



​	



## 



