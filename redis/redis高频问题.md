# redis与mysql的数据一致性

## 一致性要求

- 读请求：强一致性一律走mysql，否则从redis中读取
- 写请求：先写数据库，再写redis，否则可能redis产生脏数据

## 数据类型

- 



# 缓存穿透

大量请求不存在的数据时，缓存中没有数据会让db去处理，给db造成巨大的处理压力

1. 布隆过滤器，维护一个包含存在的数据的集合，当发现其中没有请求的数据时，直接返回
2. 每次取到不存在的数据时，都在redis上把对应数据设置为空，那么下次相同的请求就能从redis中取。但是如果是大量的不存在的数据的请求，仍旧解决不了问题，还是会让db承受巨大的压力且使redis保存了大量无用的数据。

# 缓存击穿

当一个高并发的数据的缓存失效时，还没来得及重新保存在缓存上，这时大量的请求会流转到db上。

1. 针对db的保护，用一个队列去维护让db处理的请求，也就是限流，能保护db不会宕机
2. 利用redis的互斥锁（set if no exist)，在一个时刻，设置互斥锁，只让数据库处理一个请求后并设置缓存，在新缓存设置好之前，因为在有锁的情况下，其他请求知道有请求正在请求db并且设置缓存，所以它们只需要不断尝试从redis中取缓存就可以了

# 缓存雪崩

类似缓存击穿，不同的是缓存中大面积的数据出现了缓存击穿的情况，导致大量的请求流转到db上。大致背景可分为：redis宕机 和 大量缓存同时过期失效。

1. redis宕机：可以通过主从复制+哨兵机制解决
2. 缓存集体失效：
   1. 设置缓存时使用随机的过期时间，保证数据间的过期时间不在一个点上
   2. 限流降级，减少同一时间请求到db的压力并逐渐恢复缓存